/*
 * Live Objects REST API Guide v2.12.2
 *
 * API description for Live Objects service
 *
 * API version: 2.12.2
 * Contact: liveobjects.support@orange.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package liveobjects

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	_bytes "bytes"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// DeviceManagementConnectorNodesV1ApiService DeviceManagementConnectorNodesV1Api service
type DeviceManagementConnectorNodesV1ApiService service

/*
DeleteNodeUsingDELETE Delete a connector node
Usage of this API will be reported in your access log under &#39;device_inventory&#39; category.&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_W.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param connector the connector id
 * @param nodeId the node id
 * @param xAPIKEY a valid API key
*/
func (a *DeviceManagementConnectorNodesV1ApiService) DeleteNodeUsingDELETE(ctx _context.Context, connector string, nodeId string, xAPIKEY string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/connectors/{connector}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connector"+"}", _neturl.PathEscape(parameterToString(connector, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetNodeUsingGET Get details of connector node
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;The &lt;strong&gt;activity&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastActivationTs\&quot;: (Optional) last activation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastDeactivationTs\&quot;: (Optional) last deactivation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastSignalLevel\&quot;: (Optional) last signal level&lt;/li&gt;&lt;li&gt;\&quot;lastBatteryLevel\&quot;: (Optional) last battery level&lt;/li&gt;&lt;li&gt;\&quot;lastDlFcnt\&quot;: (Optional) last downlink frame counter&lt;/li&gt;&lt;li&gt;\&quot;lastUlFcnt\&quot;: (Optional) last uplink frame counter&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastUplink\&quot;: (Optional) last uplink date of the interface&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;lastDownlink\&quot;: (Optional) last downlink date of the connector node&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;apiKeyId\&quot;: api key ID used&lt;/li&gt;&lt;li&gt;\&quot;mqttVersion\&quot;: mqtt version used&lt;/li&gt;&lt;li&gt;\&quot;mqttUsername\&quot;: mqtt username used&lt;/li&gt;&lt;li&gt;\&quot;mqttTimeout\&quot;: mqtt timeout&lt;/li&gt;&lt;li&gt;\&quot;remoteAddress\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionStartTime\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionEndTime\&quot;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_R.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param connector the connector
 * @param nodeId the node id
 * @param xAPIKEY a valid API key
@return ConnectorNode
*/
func (a *DeviceManagementConnectorNodesV1ApiService) GetNodeUsingGET(ctx _context.Context, connector string, nodeId string, xAPIKEY string) (ConnectorNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConnectorNode
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/connectors/{connector}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connector"+"}", _neturl.PathEscape(parameterToString(connector, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ListNodesUsingGETOpts Optional parameters for the method 'ListNodesUsingGET'
type ListNodesUsingGETOpts struct {
    Limit optional.Int32
    Offset optional.Int32
    XTotalCount optional.Bool
}

/*
ListNodesUsingGET List all connector nodes
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;The &lt;strong&gt;activity&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastActivationTs\&quot;: (Optional) last activation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastDeactivationTs\&quot;: (Optional) last deactivation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastSignalLevel\&quot;: (Optional) last signal level&lt;/li&gt;&lt;li&gt;\&quot;lastBatteryLevel\&quot;: (Optional) last battery level&lt;/li&gt;&lt;li&gt;\&quot;lastDlFcnt\&quot;: (Optional) last downlink frame counter&lt;/li&gt;&lt;li&gt;\&quot;lastUlFcnt\&quot;: (Optional) last uplink frame counter&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastUplink\&quot;: (Optional) last uplink date of the interface&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;lastDownlink\&quot;: (Optional) last downlink date of the connector node&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;apiKeyId\&quot;: api key ID used&lt;/li&gt;&lt;li&gt;\&quot;mqttVersion\&quot;: mqtt version used&lt;/li&gt;&lt;li&gt;\&quot;mqttUsername\&quot;: mqtt username used&lt;/li&gt;&lt;li&gt;\&quot;mqttTimeout\&quot;: mqtt timeout&lt;/li&gt;&lt;li&gt;\&quot;remoteAddress\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionStartTime\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionEndTime\&quot;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_R.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param connector the connector
 * @param xAPIKEY a valid API key
 * @param optional nil or *ListNodesUsingGETOpts - Optional Parameters:
 * @param "Limit" (optional.Int32) -  the maximum number of items per page (optional, highest value is 1000)
 * @param "Offset" (optional.Int32) -  number of items to skip (optional)
 * @param "XTotalCount" (optional.Bool) -  true if a total count must be returned in response
@return []ConnectorNode
*/
func (a *DeviceManagementConnectorNodesV1ApiService) ListNodesUsingGET(ctx _context.Context, connector string, xAPIKEY string, localVarOptionals *ListNodesUsingGETOpts) ([]ConnectorNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ConnectorNode
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/connectors/{connector}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"connector"+"}", _neturl.PathEscape(parameterToString(connector, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.XTotalCount.IsSet() {
		localVarHeaderParams["X-Total-Count"] = parameterToString(localVarOptionals.XTotalCount.Value(), "")
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateNodeUsingPATCHOpts Optional parameters for the method 'UpdateNodeUsingPATCH'
type UpdateNodeUsingPATCHOpts struct {
    Body optional.Interface
}

/*
UpdateNodeUsingPATCH Update a connector node
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Usage of this API will be reported in your access log under &#39;device_inventory&#39; category.&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_W.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param connector the connector id
 * @param nodeId the node id
 * @param xAPIKEY a valid API key
 * @param optional nil or *UpdateNodeUsingPATCHOpts - Optional Parameters:
 * @param "Body" (optional.Interface of UpdateConnectorNodeRequest) -  The fields to update
@return ConnectorNode
*/
func (a *DeviceManagementConnectorNodesV1ApiService) UpdateNodeUsingPATCH(ctx _context.Context, connector string, nodeId string, xAPIKEY string, localVarOptionals *UpdateNodeUsingPATCHOpts) (ConnectorNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConnectorNode
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/connectors/{connector}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connector"+"}", _neturl.PathEscape(parameterToString(connector, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(nodeId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(UpdateConnectorNodeRequest)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be UpdateConnectorNodeRequest")
		}
		localVarPostBody = &localVarOptionalBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
