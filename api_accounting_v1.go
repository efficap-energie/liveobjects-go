/*
 * Live Objects REST API Guide v2.12.2
 *
 * API description for Live Objects service
 *
 * API version: 2.12.2
 * Contact: liveobjects.support@orange.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package liveobjects

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	_bytes "bytes"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// AccountingV1ApiService AccountingV1Api service
type AccountingV1ApiService service

// GetDailyStatisticsUsingGET2Opts Optional parameters for the method 'GetDailyStatisticsUsingGET2'
type GetDailyStatisticsUsingGET2Opts struct {
    StartDay optional.String
    EndDay optional.String
}

/*
GetDailyStatisticsUsingGET2 Get daily accounting metrics (Beta).
&lt;p&gt;Get accounting metrics for a given period (from one day to 2 months) over the past 18 months. The data is aggregated by days.&lt;/p&gt;&lt;p&gt;The response contains 2 main sections : &lt;strong&gt;tenant&lt;/strong&gt; and &lt;strong&gt;days&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;The \&quot;&lt;strong&gt;tenant\&quot;&lt;/strong&gt; section gives useful information related to the customer. It returns the current values, whatever has been specified in startDay and endDay parameters :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;id : Live Objects identifier&lt;/li&gt;&lt;li&gt;name : tenant name in Live Objects&lt;/li&gt;&lt;li&gt;detailed offer and options, including the display name&lt;/li&gt;&lt;li&gt;properties : custom fields&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;The \&quot;&lt;strong&gt;days\&quot;&lt;/strong&gt; section provides connectors and service metrics for each day.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;connectors&lt;/strong&gt; section (LoRa, mqtt (device), mqtt application, http, sms&lt;strong&gt;_[server phone number]&lt;/strong&gt;, external) :&lt;ul&gt;&lt;li&gt;&lt;strong&gt;traffic&lt;/strong&gt; metrics:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;msg&lt;/strong&gt;: number of messages (no unit)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;bytes&lt;/strong&gt;: sum of the volume of all messages (unit: bytes)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;virtualMsg&lt;/strong&gt;: number of messages split by a size of 5kB (no unit).&lt;br /&gt;Example: 1 msg with a size of 7kB &#x3D; 1 msg and 2 virtualMsg&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;inventory&lt;/strong&gt; metrics:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;maxNumberOfEnabledNodes&lt;/strong&gt;: LoRa specific: max number of simultaneously registered LoRa interfaces for the day. Corresponding LoRa status : all status except DEACTIVATED.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;service&lt;/strong&gt; section:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;deviceManagement&lt;/strong&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;numberOfSuccessfulDownloads&lt;/strong&gt;: count of all firmware downloads in success&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;strong&gt;storage&lt;/strong&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;storedDataMessagesInMB&lt;/strong&gt;: the total size of messages stored in database.This size does not include technical data (for ex. Index).Values in MB are rounded up.The value differs from the sum of “IN” bytes sent to the platform because it includes data coming from enrichment/decoding/event processing features.This information is available from June 2019.&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Additional info&lt;/span&gt; :&lt;/p&gt;&lt;p&gt;Traffic is split by connector type (mqtt, mqtt application, sms_[server phone number], LoRa, http, external) and by directions (in/out).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;In&lt;/strong&gt;: means incoming traffic (i.e. from \&quot;outside\&quot; into Live Objects) (mostly from objects) also called &lt;strong&gt;Uplink&lt;/strong&gt;.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Out&lt;/strong&gt;: any outgoing message (i.e. from Live Objects to \&quot;outside\&quot;) except protocol messages (MQTT CONNACK, SUBACK … ) and messages consumed by applications on top of Live Objects (subscribe in MQTT application mode).&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;http specific:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;IN traffic: sum (POST /api/v0/data/bulk &amp;amp; POST /api/v0/data/streams/{streamId})&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;mqtt specific:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;IN &amp; OUT traffic: after may 2020 : the mqtt section contains only traffic in device mode. Mqtt application mode is computed only for incoming traffic (IN).&lt;/li&gt;&lt;/ul&gt;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xAPIKEY a valid API key
 * @param optional nil or *GetDailyStatisticsUsingGET2Opts - Optional Parameters:
 * @param "StartDay" (optional.String) -  the requested start day as yyyy-MM-dd. If missing, the current day is used.
 * @param "EndDay" (optional.String) -  the requested end day as yyyy-MM-dd. If missing, the current day is used.
@return TenantDayMetrics
*/
func (a *AccountingV1ApiService) GetDailyStatisticsUsingGET2(ctx _context.Context, xAPIKEY string, localVarOptionals *GetDailyStatisticsUsingGET2Opts) (TenantDayMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TenantDayMetrics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/accounting/daily"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.StartDay.IsSet() {
		localVarQueryParams.Add("startDay", parameterToString(localVarOptionals.StartDay.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndDay.IsSet() {
		localVarQueryParams.Add("endDay", parameterToString(localVarOptionals.EndDay.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetMonthlyStatisticsUsingGET2Opts Optional parameters for the method 'GetMonthlyStatisticsUsingGET2'
type GetMonthlyStatisticsUsingGET2Opts struct {
    StartMonth optional.String
    EndMonth optional.String
}

/*
GetMonthlyStatisticsUsingGET2 Get monthly accounting metrics.
&lt;p&gt;Get accounting metrics for a given period (up to 18 months). The data is aggregated by months.&lt;/p&gt;&lt;p&gt;The response contains 2 main sections : &lt;strong&gt;tenant&lt;/strong&gt; and &lt;strong&gt;months&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;The \&quot;&lt;strong&gt;tenant\&quot;&lt;/strong&gt; section gives useful information related to the customer. It returns the current values, whatever has been specified in startMonth and endMonth parameters :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;id : Live Objects identifier&lt;/li&gt;&lt;li&gt;name : tenant name in Live Objects&lt;/li&gt;&lt;li&gt;detailed offer and options, including the display name&lt;/li&gt;&lt;li&gt;properties : custom fields&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br /&gt;The \&quot;&lt;strong&gt;months\&quot;&lt;/strong&gt; section provides connectors and service metrics for each month.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;connectors&lt;/strong&gt; section (LoRa, mqtt (device), mqtt application, http, sms&lt;strong&gt;_[server phone number]&lt;/strong&gt;, external) :&lt;ul&gt;&lt;li&gt;&lt;strong&gt;traffic&lt;/strong&gt; metrics:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;msg&lt;/strong&gt;: number of messages (no unit)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;bytes&lt;/strong&gt;: sum of the volume of all messages (unit: bytes)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;virtualMsg&lt;/strong&gt;: number of messages split by a size of 5kB (no unit).&lt;br /&gt;Example: 1 msg with a size of 7kB &#x3D; 1 msg and 2 virtualMsg&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;inventory&lt;/strong&gt; metrics:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;numberOfCommunicatingNodes&lt;/strong&gt;: this counter is available by connector: LoRa, mqtt, sms_[server phone number] or external. It is a unique count of devices that send at least one uplink message to the platform (except for mqtt, see below). More precisely, by connector:&lt;ul&gt;&lt;li&gt;LoRa: distinct devEUIs sending an uplink&lt;/li&gt;&lt;li&gt;mqtt: distinct clientIds that have been connected at least one time&lt;/li&gt;&lt;li&gt;external: distinct nodeIds behind an external connector that have been declared online or have published a dataMessage&lt;/li&gt;&lt;li&gt;sms: distinct MSISDNs sending a message&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;numberOfActivatedNodes&lt;/strong&gt;: LoRa specific: count of unique devices allowed to communicate and paired to the network. Corresponding LoRa status : ACTIVATED or INITIALIZED.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;numberOfActivatedTdoaNodes&lt;/strong&gt;: LoRa specific: count of unique Activated devices that had TDOA lora option for the month.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;numberOfActivatedAckUlNodes&lt;/strong&gt;: LoRa specific: count of unique Activated devices that had AckUL lora option for the month. &lt;/ul&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;service&lt;/strong&gt; section:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;deviceManagement&lt;/strong&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;numberOfSuccessfulDownloads&lt;/strong&gt;: count of all firmware downloads in success&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;strong&gt;storage&lt;/strong&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;storedDataMessagesInMB&lt;/strong&gt;: the total size of messages stored in database.This size does not include technical data (for ex. Index).Values in MB are rounded up.The value differs from the sum of “IN” bytes sent to the platform because it includes data coming from enrichment/decoding/event processing features.This information is available from June 2019.&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Additional info&lt;/span&gt; :&lt;/p&gt;&lt;p&gt;Traffic is split by connector type (mqtt, mqtt application, sms_[server phone number], LoRa, http, external) and by directions (in/out).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;In&lt;/strong&gt;: means incoming traffic (i.e. from \&quot;outside\&quot; into Live Objects) (mostly from objects) also called &lt;strong&gt;Uplink&lt;/strong&gt;.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Out&lt;/strong&gt;: any outgoing message (i.e. from Live Objects to \&quot;outside\&quot;) except protocol messages (MQTT CONNACK, SUBACK … ) and messages consumed by applications on top of Live Objects (subscribe in MQTT application mode).&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;http specific:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;IN traffic: sum (POST /api/v0/data/bulk &amp;amp; POST /api/v0/data/streams/{streamId})&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;mqtt specific:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;IN &amp; OUT traffic: after may 2020 : the mqtt section contains only traffic in device mode. Mqtt application mode is computed only for incoming traffic (IN).&lt;/li&gt;&lt;/ul&gt;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param xAPIKEY a valid API key
 * @param optional nil or *GetMonthlyStatisticsUsingGET2Opts - Optional Parameters:
 * @param "StartMonth" (optional.String) -  the requested start month as yyyy-MM. If missing, the current month is used.
 * @param "EndMonth" (optional.String) -  the requested end month as yyyy-MM. If missing, the current month is used.
@return TenantMonthMetrics
*/
func (a *AccountingV1ApiService) GetMonthlyStatisticsUsingGET2(ctx _context.Context, xAPIKEY string, localVarOptionals *GetMonthlyStatisticsUsingGET2Opts) (TenantMonthMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TenantMonthMetrics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/accounting/monthly"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.StartMonth.IsSet() {
		localVarQueryParams.Add("startMonth", parameterToString(localVarOptionals.StartMonth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndMonth.IsSet() {
		localVarQueryParams.Add("endMonth", parameterToString(localVarOptionals.EndMonth.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
