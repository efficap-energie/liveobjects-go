/*
 * Live Objects REST API Guide v2.13.3
 *
 * API description for Live Objects service
 *
 * API version: 2.13.3
 * Contact: liveobjects.support@orange.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package liveobjects

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// AccountingV1ApiService AccountingV1Api service
type AccountingV1ApiService service

type ApiGetDailyStatisticsUsingGET2Request struct {
	ctx _context.Context
	ApiService *AccountingV1ApiService
	xAPIKEY *string
	startDay *string
	endDay *string
}

func (r ApiGetDailyStatisticsUsingGET2Request) XAPIKEY(xAPIKEY string) ApiGetDailyStatisticsUsingGET2Request {
	r.xAPIKEY = &xAPIKEY
	return r
}
func (r ApiGetDailyStatisticsUsingGET2Request) StartDay(startDay string) ApiGetDailyStatisticsUsingGET2Request {
	r.startDay = &startDay
	return r
}
func (r ApiGetDailyStatisticsUsingGET2Request) EndDay(endDay string) ApiGetDailyStatisticsUsingGET2Request {
	r.endDay = &endDay
	return r
}

func (r ApiGetDailyStatisticsUsingGET2Request) Execute() (TenantDayMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetDailyStatisticsUsingGET2Execute(r)
}

/*
 * GetDailyStatisticsUsingGET2 Get daily accounting metrics (Beta).
 * <p>Get accounting metrics for a given period (from one day to 2 months) over the past 18 months. The data is aggregated by days.</p><p>The response contains 2 main sections : <strong>tenant</strong> and <strong>days</strong>.</p><p>The "<strong>tenant"</strong> section gives useful information related to the customer. It returns the current values, whatever has been specified in startDay and endDay parameters :</p><ul><li>id : Live Objects identifier</li><li>name : tenant name in Live Objects</li><li>detailed offer and options, including the display name</li><li>properties : custom fields</li></ul><p><br />The "<strong>days"</strong> section provides connectors and service metrics for each day.</p><ul><li><strong>connectors</strong> section (LoRa, mqtt (device), mqtt application, http, sms<strong>_[server phone number]</strong>, external) :<ul><li><strong>traffic</strong> metrics:<ul><li><strong>msg</strong>: number of messages (no unit)</li><li><strong>bytes</strong>: sum of the volume of all messages (unit: bytes)</li><li><strong>virtualMsg</strong>: number of messages split by a size of 5kB (no unit).<br />Example: 1 msg with a size of 7kB = 1 msg and 2 virtualMsg</li></ul></li><li><strong>inventory</strong> metrics:<ul><li><strong>maxNumberOfEnabledNodes</strong>: LoRa specific: max number of simultaneously registered LoRa interfaces for the day. Corresponding LoRa status : all status except DEACTIVATED.</li></ul></li><li><strong>service</strong> section:<ul><li><strong>deviceManagement</strong></li><ul><li><strong>numberOfSuccessfulDownloads</strong>: count of all firmware downloads in success</li></ul><li><strong>storage</strong></li><ul><li><strong>storedDataMessagesInMB</strong>: the total size of messages stored in database.This size does not include technical data (for ex. Index).Values in MB are rounded up.The value differs from the sum of “IN” bytes sent to the platform because it includes data coming from enrichment/decoding/event processing features.This information is available from June 2019.</li></ul></ul></li></ul></ul><p><span style="text-decoration: underline;">Additional info</span> :</p><p>Traffic is split by connector type (mqtt, mqtt application, sms_[server phone number], LoRa, http, external) and by directions (in/out).</p><ul><li><strong>In</strong>: means incoming traffic (i.e. from "outside" into Live Objects) (mostly from objects) also called <strong>Uplink</strong>.</li><li><strong>Out</strong>: any outgoing message (i.e. from Live Objects to "outside") except protocol messages (MQTT CONNACK, SUBACK … ) and messages consumed by applications on top of Live Objects (subscribe in MQTT application mode).<br /><br /></li></ul><p><strong>http specific:</strong></p><ul><li>IN traffic: sum (POST /api/v0/data/bulk &amp; POST /api/v0/data/streams/{streamId})</li></ul><p><strong>mqtt specific:</strong></p><ul><li>IN & OUT traffic: after may 2020 : the mqtt section contains only traffic in device mode. Mqtt application mode is computed only for incoming traffic (IN).</li></ul>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDailyStatisticsUsingGET2Request
 */
func (a *AccountingV1ApiService) GetDailyStatisticsUsingGET2(ctx _context.Context) ApiGetDailyStatisticsUsingGET2Request {
	return ApiGetDailyStatisticsUsingGET2Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return TenantDayMetrics
 */
func (a *AccountingV1ApiService) GetDailyStatisticsUsingGET2Execute(r ApiGetDailyStatisticsUsingGET2Request) (TenantDayMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TenantDayMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingV1ApiService.GetDailyStatisticsUsingGET2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounting/daily"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xAPIKEY == nil {
		return localVarReturnValue, nil, reportError("xAPIKEY is required and must be specified")
	}

	if r.startDay != nil {
		localVarQueryParams.Add("startDay", parameterToString(*r.startDay, ""))
	}
	if r.endDay != nil {
		localVarQueryParams.Add("endDay", parameterToString(*r.endDay, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(*r.xAPIKEY, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonthlyStatisticsUsingGET2Request struct {
	ctx _context.Context
	ApiService *AccountingV1ApiService
	xAPIKEY *string
	startMonth *string
	endMonth *string
}

func (r ApiGetMonthlyStatisticsUsingGET2Request) XAPIKEY(xAPIKEY string) ApiGetMonthlyStatisticsUsingGET2Request {
	r.xAPIKEY = &xAPIKEY
	return r
}
func (r ApiGetMonthlyStatisticsUsingGET2Request) StartMonth(startMonth string) ApiGetMonthlyStatisticsUsingGET2Request {
	r.startMonth = &startMonth
	return r
}
func (r ApiGetMonthlyStatisticsUsingGET2Request) EndMonth(endMonth string) ApiGetMonthlyStatisticsUsingGET2Request {
	r.endMonth = &endMonth
	return r
}

func (r ApiGetMonthlyStatisticsUsingGET2Request) Execute() (TenantMonthMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMonthlyStatisticsUsingGET2Execute(r)
}

/*
 * GetMonthlyStatisticsUsingGET2 Get monthly accounting metrics.
 * <p>Get accounting metrics for a given period (up to 18 months). The data is aggregated by months.</p><p>The response contains 2 main sections : <strong>tenant</strong> and <strong>months</strong>.</p><p>The "<strong>tenant"</strong> section gives useful information related to the customer. It returns the current values, whatever has been specified in startMonth and endMonth parameters :</p><ul><li>id : Live Objects identifier</li><li>name : tenant name in Live Objects</li><li>detailed offer and options, including the display name</li><li>properties : custom fields</li></ul><p><br />The "<strong>months"</strong> section provides connectors and service metrics for each month.</p><ul><li><strong>connectors</strong> section (LoRa, mqtt (device), mqtt application, http, sms<strong>_[server phone number]</strong>, external) :<ul><li><strong>traffic</strong> metrics:<ul><li><strong>msg</strong>: number of messages (no unit)</li><li><strong>bytes</strong>: sum of the volume of all messages (unit: bytes)</li><li><strong>virtualMsg</strong>: number of messages split by a size of 5kB (no unit).<br />Example: 1 msg with a size of 7kB = 1 msg and 2 virtualMsg</li></ul></li><li><strong>inventory</strong> metrics:<ul><li><strong>numberOfCommunicatingNodes</strong>: this counter is available by connector: LoRa, mqtt, sms_[server phone number] or external. It is a unique count of devices that send at least one uplink message to the platform (except for mqtt, see below). More precisely, by connector:<ul><li>LoRa: distinct devEUIs sending an uplink</li><li>mqtt: distinct clientIds that have been connected at least one time</li><li>external: distinct nodeIds behind an external connector that have been declared online or have published a dataMessage</li><li>sms: distinct MSISDNs sending a message</li></ul></li><li><strong>numberOfActivatedNodes</strong>: LoRa specific: count of unique devices allowed to communicate and paired to the network. Corresponding LoRa status : ACTIVATED or INITIALIZED.</li><li><strong>numberOfActivatedTdoaNodes</strong>: LoRa specific: count of unique Activated devices that had TDOA lora option for the month.</li><li><strong>numberOfActivatedAckUlNodes</strong>: LoRa specific: count of unique Activated devices that had AckUL lora option for the month. </ul></ul></li></ul><ul><li><strong>service</strong> section:<ul><li><strong>deviceManagement</strong></li><ul><li><strong>numberOfSuccessfulDownloads</strong>: count of all firmware downloads in success</li></ul><li><strong>storage</strong></li><ul><li><strong>storedDataMessagesInMB</strong>: the total size of messages stored in database.This size does not include technical data (for ex. Index).Values in MB are rounded up.The value differs from the sum of “IN” bytes sent to the platform because it includes data coming from enrichment/decoding/event processing features.This information is available from June 2019.</li></ul></ul></li></ul><p><span style="text-decoration: underline;">Additional info</span> :</p><p>Traffic is split by connector type (mqtt, mqtt application, sms_[server phone number], LoRa, http, external) and by directions (in/out).</p><ul><li><strong>In</strong>: means incoming traffic (i.e. from "outside" into Live Objects) (mostly from objects) also called <strong>Uplink</strong>.</li><li><strong>Out</strong>: any outgoing message (i.e. from Live Objects to "outside") except protocol messages (MQTT CONNACK, SUBACK … ) and messages consumed by applications on top of Live Objects (subscribe in MQTT application mode).<br /><br /></li></ul><p><strong>http specific:</strong></p><ul><li>IN traffic: sum (POST /api/v0/data/bulk &amp; POST /api/v0/data/streams/{streamId})</li></ul><p><strong>mqtt specific:</strong></p><ul><li>IN & OUT traffic: after may 2020 : the mqtt section contains only traffic in device mode. Mqtt application mode is computed only for incoming traffic (IN).</li></ul>
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetMonthlyStatisticsUsingGET2Request
 */
func (a *AccountingV1ApiService) GetMonthlyStatisticsUsingGET2(ctx _context.Context) ApiGetMonthlyStatisticsUsingGET2Request {
	return ApiGetMonthlyStatisticsUsingGET2Request{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return TenantMonthMetrics
 */
func (a *AccountingV1ApiService) GetMonthlyStatisticsUsingGET2Execute(r ApiGetMonthlyStatisticsUsingGET2Request) (TenantMonthMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TenantMonthMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountingV1ApiService.GetMonthlyStatisticsUsingGET2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/accounting/monthly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.xAPIKEY == nil {
		return localVarReturnValue, nil, reportError("xAPIKEY is required and must be specified")
	}

	if r.startMonth != nil {
		localVarQueryParams.Add("startMonth", parameterToString(*r.startMonth, ""))
	}
	if r.endMonth != nil {
		localVarQueryParams.Add("endMonth", parameterToString(*r.endMonth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(*r.xAPIKEY, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
