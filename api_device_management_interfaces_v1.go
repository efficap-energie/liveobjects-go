/*
 * Live Objects REST API Guide v2.12.2
 *
 * API description for Live Objects service
 *
 * API version: 2.12.2
 * Contact: liveobjects.support@orange.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package liveobjects

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	_bytes "bytes"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// DeviceManagementInterfacesV1ApiService DeviceManagementInterfacesV1Api service
type DeviceManagementInterfacesV1ApiService service

// AddInterfaceToDeviceUsingPOSTOpts Optional parameters for the method 'AddInterfaceToDeviceUsingPOST'
type AddInterfaceToDeviceUsingPOSTOpts struct {
    NewDeviceInterface optional.Interface
}

/*
AddInterfaceToDeviceUsingPOST Add an interface to a registered device
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Usage of this API will be reported in your access log under &#39;device_inventory&#39; category.&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_W.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId device identifier. A Live Objects URN 'urn:lo:nsid:{namespace}:{id}' must respect the following regular expression <code>^urn:lo:nsid:([\\w\\-_]{1,128}):([\\w\\-_:]{1,128})$</code> (max 269 characters)
 * @param xAPIKEY a valid API key
 * @param optional nil or *AddInterfaceToDeviceUsingPOSTOpts - Optional Parameters:
 * @param "NewDeviceInterface" (optional.Interface of NewDeviceInterface) -  The device interface to add
@return DeviceInterface
*/
func (a *DeviceManagementInterfacesV1ApiService) AddInterfaceToDeviceUsingPOST(ctx _context.Context, deviceId string, xAPIKEY string, localVarOptionals *AddInterfaceToDeviceUsingPOSTOpts) (DeviceInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/devices/{deviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", _neturl.PathEscape(parameterToString(deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	// body params
	if localVarOptionals != nil && localVarOptionals.NewDeviceInterface.IsSet() {
		localVarOptionalNewDeviceInterface, localVarOptionalNewDeviceInterfaceok := localVarOptionals.NewDeviceInterface.Value().(NewDeviceInterface)
		if !localVarOptionalNewDeviceInterfaceok {
			return localVarReturnValue, nil, reportError("newDeviceInterface should be NewDeviceInterface")
		}
		localVarPostBody = &localVarOptionalNewDeviceInterface
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DeleteInterfaceUsingDELETE Delete an interface
Usage of this API will be reported in your access log under &#39;device_inventory&#39; category.&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_W.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId device identifier. A Live Objects URN 'urn:lo:nsid:{namespace}:{id}' must respect the following regular expression <code>^urn:lo:nsid:([\\w\\-_]{1,128}):([\\w\\-_:]{1,128})$</code> (max 269 characters)
 * @param interfaceId Must be {connector}:{nodeId}.
 * @param xAPIKEY a valid API key
*/
func (a *DeviceManagementInterfacesV1ApiService) DeleteInterfaceUsingDELETE(ctx _context.Context, deviceId string, interfaceId string, xAPIKEY string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/devices/{deviceId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", _neturl.PathEscape(parameterToString(deviceId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", _neturl.PathEscape(parameterToString(interfaceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetInterfaceForADeviceUsingGET Get a specific interface for a registered device
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;The &lt;strong&gt;activity&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastActivationTs\&quot;: (Optional) last activation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastDeactivationTs\&quot;: (Optional) last deactivation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastSignalLevel\&quot;: (Optional) last signal level&lt;/li&gt;&lt;li&gt;\&quot;lastBatteryLevel\&quot;: (Optional) last battery level&lt;/li&gt;&lt;li&gt;\&quot;lastDlFcnt\&quot;: (Optional) last downlink frame counter&lt;/li&gt;&lt;li&gt;\&quot;lastUlFcnt\&quot;: (Optional) last uplink frame counter&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastUplink\&quot;: (Optional) last uplink date of the interface&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;lastDownlink\&quot;: (Optional) last downlink date of the connector node&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;apiKeyId\&quot;: api key ID used&lt;/li&gt;&lt;li&gt;\&quot;mqttVersion\&quot;: mqtt version used&lt;/li&gt;&lt;li&gt;\&quot;mqttUsername\&quot;: mqtt username used&lt;/li&gt;&lt;li&gt;\&quot;mqttTimeout\&quot;: mqtt timeout&lt;/li&gt;&lt;li&gt;\&quot;remoteAddress\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionStartTime\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionEndTime\&quot;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_R.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId device identifier. A Live Objects URN 'urn:lo:nsid:{namespace}:{id}' must respect the following regular expression <code>^urn:lo:nsid:([\\w\\-_]{1,128}):([\\w\\-_:]{1,128})$</code> (max 269 characters)
 * @param interfaceId Must be {connector}:{nodeId}
 * @param xAPIKEY a valid API key
@return DeviceInterface
*/
func (a *DeviceManagementInterfacesV1ApiService) GetInterfaceForADeviceUsingGET(ctx _context.Context, deviceId string, interfaceId string, xAPIKEY string) (DeviceInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/devices/{deviceId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", _neturl.PathEscape(parameterToString(deviceId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", _neturl.PathEscape(parameterToString(interfaceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ListInterfacesForADeviceUsingGET Get the interface list for a registered device
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;p&gt;The &lt;strong&gt;activity&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastActivationTs\&quot;: (Optional) last activation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastDeactivationTs\&quot;: (Optional) last deactivation date of the interface&lt;/li&gt;&lt;li&gt;\&quot;lastSignalLevel\&quot;: (Optional) last signal level&lt;/li&gt;&lt;li&gt;\&quot;lastBatteryLevel\&quot;: (Optional) last battery level&lt;/li&gt;&lt;li&gt;\&quot;lastDlFcnt\&quot;: (Optional) last downlink frame counter&lt;/li&gt;&lt;li&gt;\&quot;lastUlFcnt\&quot;: (Optional) last uplink frame counter&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;lastUplink\&quot;: (Optional) last uplink date of the interface&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;lastDownlink\&quot;: (Optional) last downlink date of the connector node&lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;timestamp\&quot;: date of the activity&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: server phone number used&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT activity&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;apiKeyId\&quot;: api key ID used&lt;/li&gt;&lt;li&gt;\&quot;mqttVersion\&quot;: mqtt version used&lt;/li&gt;&lt;li&gt;\&quot;mqttUsername\&quot;: mqtt username used&lt;/li&gt;&lt;li&gt;\&quot;mqttTimeout\&quot;: mqtt timeout&lt;/li&gt;&lt;li&gt;\&quot;remoteAddress\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionStartTime\&quot;&lt;/li&gt;&lt;li&gt;\&quot;lastSessionEndTime\&quot;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_R.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId device identifier. A Live Objects URN 'urn:lo:nsid:{namespace}:{id}' must respect the following regular expression <code>^urn:lo:nsid:([\\w\\-_]{1,128}):([\\w\\-_:]{1,128})$</code> (max 269 characters)
 * @param xAPIKEY a valid API key
@return []DeviceInterface
*/
func (a *DeviceManagementInterfacesV1ApiService) ListInterfacesForADeviceUsingGET(ctx _context.Context, deviceId string, xAPIKEY string) ([]DeviceInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DeviceInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/devices/{deviceId}/interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", _neturl.PathEscape(parameterToString(deviceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateInterfaceUsingPATCHOpts Optional parameters for the method 'UpdateInterfaceUsingPATCH'
type UpdateInterfaceUsingPATCHOpts struct {
    Body optional.Interface
}

/*
UpdateInterfaceUsingPATCH Update an interface
&lt;p&gt;The &lt;strong&gt;definition&lt;/strong&gt; depends on connector.&lt;/p&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;Lora definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;devEUI\&quot;: interface EUI&lt;/li&gt;&lt;li&gt;\&quot;appEUI\&quot;: appEUI of the interface&lt;/li&gt;&lt;li&gt;\&quot;appKey\&quot;: appKey of the interface&lt;/li&gt;&lt;li&gt;\&quot;activationType\&quot;: supported value: \&quot;OTAA\&quot;&lt;/li&gt;&lt;li&gt;\&quot;profile\&quot;: profile of the interface&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) encoding type of the binary payload sent by the interface&lt;/li&gt;&lt;li&gt;\&quot;connectivityOptions\&quot;: connectivity options used for the interface &lt;/li&gt;&lt;ul&gt;&lt;li&gt;\&quot;tdoa\&quot;: true/false &lt;/li&gt;&lt;li&gt;\&quot;ackUl\&quot;: true/false&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;\&quot;connectivityPlan\&quot;: connectivity plan to use for the interface. Should be used preferably at connectivityOptions but at least one of two shall be defined.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;SMS definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;msisdn\&quot;: interface msisdn&lt;/li&gt;&lt;li&gt;\&quot;serverPhoneNumber\&quot;: (Optional) server phone number&lt;/li&gt;&lt;li&gt;\&quot;encoding\&quot;: (Optional) name of the decoder that will be used to decode received SMS&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;MQTT definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;clientId\&quot;: interface client ID&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style&#x3D;\&quot;text-decoration: underline;\&quot;&gt;X-CONNECTOR definition&lt;/span&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\&quot;nodeId\&quot;: id used by the external connector to identify the communicating device (e.g. PUB connector/v1/nodes/{nodeId}/status)&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;Usage of this API will be reported in your access log under &#39;device_inventory&#39; category.&lt;br&gt;&lt;br&gt;Restricted to API keys with at least one of the following roles : DEVICE_W.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId device identifier. A Live Objects URN 'urn:lo:nsid:{namespace}:{id}' must respect the following regular expression <code>^urn:lo:nsid:([\\w\\-_]{1,128}):([\\w\\-_:]{1,128})$</code> (max 269 characters)
 * @param interfaceId Must be {connector}:{nodeId}
 * @param xAPIKEY a valid API key
 * @param optional nil or *UpdateInterfaceUsingPATCHOpts - Optional Parameters:
 * @param "Body" (optional.Interface of UpdateInterfaceReqWeb) -  The fields to update
@return DeviceInterface
*/
func (a *DeviceManagementInterfacesV1ApiService) UpdateInterfaceUsingPATCH(ctx _context.Context, deviceId string, interfaceId string, xAPIKEY string, localVarOptionals *UpdateInterfaceUsingPATCHOpts) (DeviceInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/deviceMgt/devices/{deviceId}/interfaces/{interfaceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", _neturl.PathEscape(parameterToString(deviceId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"interfaceId"+"}", _neturl.PathEscape(parameterToString(interfaceId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-KEY"] = parameterToString(xAPIKEY, "")
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().(UpdateInterfaceReqWeb)
		if !localVarOptionalBodyok {
			return localVarReturnValue, nil, reportError("body should be UpdateInterfaceReqWeb")
		}
		localVarPostBody = &localVarOptionalBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(_bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseWeb
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
